<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>EvReact by vslab</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>EvReact</h1>
        <h2>A lightweight framework for reactive programming</h2>

        <section id="downloads">
          <a href="https://github.com/vslab/evreact/zipball/master" class="btn">Download as .zip</a>
          <a href="https://www.nuget.org/packages/evReact/0.9.0" class="btn"><span class="icon"></span>Package on NuGet</a>
          <a href="https://github.com/vslab/evreact" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a id="evreact" class="anchor" href="#evreact" aria-hidden="true"><span class="octicon octicon-link"></span></a>evReact</h3>

<h1>
<a id="what" class="anchor" href="#what" aria-hidden="true"><span class="octicon octicon-link"></span></a>What</h1>

<p>
  Reactive programming is important ingredient since reactive systems
  (as defined by the <a href="http://www.reactivemanifesto.org/">Reactive Manifesto</a>)
  are becoming so widely developed. 
  The <em>evReact</em> library is an event based control flow management library for
  supporting this type of programming.
 </p>

<p>
  Using few compositional operators it is possible to define an event-tracking system
  that allows to fire handlers only when a particular sequence of events is detected.
</p>

<p>
  We believe that the approach we adopted for <em>evReact</em> has the potential to become
  a primitive construct for programming languages.
</p>

<h1>
<a id="why" class="anchor" href="#why" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why</h1>

<p>
  Using this lightweight support for recognizing sequence of events it is possible
  to overlay workflows into programs. There are several applications including:
</p>

<ul>
  <li>Compositional gesture recognition like the one in the <a href="http://gestit.github.io/GestIT/">GestIT</a> library</li>
  <li>Control flow serialization is possible since evReact control flow is represented as a serializable data structure.</li>
  <li>Internal program tracking for ensuring that the program is in a well known macrostate before executing some code.</li>
  <li>Hirearchical events handling (i.e. expressions recognizing different but analogous events fire meta events into other expressions).</li>
  <li>Handling related events with unbound args (i.e. multitouch events with arbitrary number of touches).</li>
  <li>The model supports event orchestration across different processes, supporting distributed application
    development like Web apps.
  </li>
  <li>The framework is so lightweight it can run almost everywhere, including in the typical IoT devices.</li>
</ul>

<p>
  Expressions generates Petri networks that are responsible for recognizing the event sequences. Generated Nets
  are not Turing Complete, though completeness is achievable by dynamic net generation. This esnure a good mix of
  verifiability and expressivity.
</p>

<h1>
<a id="where" class="anchor" href="#where" aria-hidden="true"><span class="octicon octicon-link"></span></a>Where</h1>

<p>
  The <em>evReact</em> library is primarily developed in F# and is available to .NET languages. 
  We are adding ports to other programming systems the programming model. The Typescript/Javascript
  implementation is already available. Python and Java implementations are under development.
</p>

<h1>
<a id="how" class="anchor" href="#how" aria-hidden="true"><span class="octicon octicon-link"></span></a>How</h1>
  
 <p>The programming model of <em>evReact</em> is based on composing events with a small list of operators:</p>
 <table>
   <thead>
     <th>Operator</th>
     <th>F# syntax</th>
     <th>Description</th>
   </thead>
   <tbody>
     <tr>
       <td>Ground</td>
       <td><code>!!</code></td>
       <td>
         This operator is used to bind an event to a node of the expression.
       </td>
     </tr>
     <tr>
       <td>Filtered ground</td>
       <td><code>%-</code></td>
       <td>
         This operator is similar to <code>!!</code> but it allows to accept events
         only if a give condition is met.
       </td>
     </tr>
     <tr>
       <td>Action</td>
       <td><code>|-></code></code></td>
       <td>
         With the action operator is possible to trigger a function when an expression
         recognize the sequence of events.
       </td>
     </tr>
     <tr>
       <td>Fault handling</td>
       <td><code>|=></code></code></td>
       <td>
         Like in the <code>try/finally</code> construct of many languages this operator allows to
         execute an action when an expression either completes or fails.  
       </td>
     </tr>
     <tr>
       <td>Sequence</td>
       <td><code>-</code></td>
       <td>
         With the sequence operator it is possible to recognize an event only 
         after another (or an expression involving events) happened. For instance
         the expression <code>!!A - (!!B |-> fun () -> printfn "B!")</code> prints
         <code>B!</code> only after the event A happens. 
       </td>
     </tr>
     <tr>
       <td>Iter</td>
       <td><code>+</code></td>
       <td>
         If an expression involving events is prefixed with this operator the events sequence
         is recognized many times.
       </td>
     </tr>
     <tr>
       <td>All</td>
       <td><code>&amp;&amp;&amp;</code></td>
       <td>
         The expression <code>(!!A &amp;&amp;&amp; !!B &amp;&amp;&amp; !!C)</code> recognize
         the event <code>A</code>, <code>B</code> and <code>C</code> and completes only when
         all the three events are recognized.
       </td>
     </tr>
     <tr>
       <td>Any</td>
       <td><code>|||</code></td>
       <td>
         This operator is similar to the all operator but in this case any of the subexpressions
         completes the whole expression completes (abandoning the recognition of the uncomplete
         expressions).
       </td>
     </tr>
     <tr>
       <td>Restrict</td>
       <td><code>/</code></td>
       <td>
         The event recognizer usually ignores the events different by those expected by an expression.
         For instance in the sequence <code>(!!A - !!B)</code> if <code>A</code> is expected and <code>B</code>
         or any other event happens the events are ignored. The restriction allows to restrict an expression
         over a given alphabet of events; for instance in <code>(!!A - !!B)/[A;B]</code> if <code>B</code> happens
         while <code>A</code> is expected the whole recognition fails.
       </td>
     </tr>
   </tbody>
 </table> 

<h1>
<a id="who" class="anchor" href="#who" aria-hidden="true"><span class="octicon octicon-link"></span></a>Who</h1>
 
<p>
  <em>evReact</em> is a library with a quite long history. The early studies on how to use Petri Nets for
  recognizing complex events sequences for composable gesture recognition were conducted by Davide Spano during his PhD,
  under the supervision of Prof. Antonio Cisternino (<a href="http://twitter.com/cisterni">@cisterni</a>).
  This led to a first implementation of GestIT with a strict semantics developed in C#. The library was then re-designed
  and re-implemented using F# with a better and more composable semantics by Andrea Canciani and Marta Martino.
  During the second implementation we found the programming model widely applicable than just the gesture definitions.
  This led to the current <em>evReact</em> implementation (and PhD work) by Andrea Canciani under the supervision of
  Prof. Antonio Cisternino. <em>GestIT</em> will be eventually rewritten based on <em>evReact</em>. Under this last
  rewriting more attention has been paid to critical aspects of semantics such as concurrency.
</p>
      </section>
    </div>

    
  </body>
</html>